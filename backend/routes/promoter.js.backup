const express = require('express')
const router = express.Router()
const { Pool } = require('pg')
require('dotenv').config()

// Database connection
const db = new Pool({
  connectionString: process.env.DATABASE_URL || "postgresql://postgres:Eventu321@localhost:5432/eventu_db",
})

const { auth, requireRole } = require('../middleware/auth')

// Middleware para verificar que el usuario es promotor
const requirePromoter = (req, res, next) => {
  if (!req.user) {
    return res.status(401).json({ success: false, error: 'No autorizado' })
  }
  
  if (req.user.role !== 'promoter') {
    return res.status(403).json({ success: false, error: 'Acceso denegado. Se requieren permisos de promotor.' })
  }
  
  next()
}

// GET /api/promoter/dashboard - Dashboard principal del promotor
router.get('/dashboard', auth, requirePromoter, async (req, res) => {
  try {
    const promoterId = req.user.id

    // Obtener eventos del promotor
    const eventsQuery = `
      SELECT 
        e.id,
        e.title,
        e.description,
        e.date,
        e.time,
        e.venue,
        e.status,
        e.created_at,
        c.name as category_name,
        COALESCE(e.total_capacity, 0) as capacity,
        COALESCE(e.price, 0) as price
      FROM events e
      LEFT JOIN categories c ON e.category_id = c.id
      WHERE e.promoter_id = $1
      ORDER BY e.created_at DESC
      LIMIT 10
    `

    // Obtener estadísticas generales del promotor
    const statsQuery = `
      SELECT 
        COUNT(*) as total_events,
        COUNT(CASE WHEN status = 'published' THEN 1 END) as published_events,
        COUNT(CASE WHEN status = 'draft' THEN 1 END) as draft_events,
        COUNT(CASE WHEN status = 'cancelled' THEN 1 END) as cancelled_events,
        COUNT(CASE WHEN created_at >= NOW() - INTERVAL '30 days' THEN 1 END) as new_events_30_days
      FROM events 
      WHERE promoter_id = $1
    `

    // Obtener estadísticas de ventas del promotor
    const salesQuery = `
      SELECT 
        COUNT(*) as total_sales,
        COALESCE(SUM(s.total_amount), 0) as total_revenue,
        COUNT(DISTINCT s.event_id) as events_with_sales,
        COUNT(CASE WHEN s.status = 'completed' THEN 1 END) as completed_sales,
        COUNT(CASE WHEN s.status = 'pending' THEN 1 END) as pending_sales,
        COUNT(CASE WHEN s.status = 'failed' THEN 1 END) as failed_sales,
        COALESCE(AVG(s.total_amount), 0) as avg_ticket_price
      FROM sales s
      INNER JOIN events e ON s.event_id = e.id
      WHERE e.promoter_id = $1
        AND s.transaction_date >= NOW() - INTERVAL '30 days'
    `

    // Obtener eventos recientes con ventas
    const recentEventsQuery = `
      SELECT 
        e.id,
        e.title,
        e.date,
        e.status,
        COUNT(s.id) as total_sales,
        COALESCE(SUM(s.total_amount), 0) as total_revenue,
        COUNT(CASE WHEN s.status = 'completed' THEN 1 END) as completed_sales
      FROM events e
      LEFT JOIN sales s ON e.id = s.event_id
      WHERE e.promoter_id = $1
      GROUP BY e.id, e.title, e.date, e.status
      ORDER BY e.date DESC
      LIMIT 5
    `

    const [eventsResult, statsResult, salesResult, recentEventsResult] = await Promise.all([
      db.query(eventsQuery, [promoterId]),
      db.query(statsQuery, [promoterId]),
      db.query(salesQuery, [promoterId]),
      db.query(recentEventsQuery, [promoterId])
    ])

    const stats = statsResult.rows[0]
    const sales = salesResult.rows[0]

    res.json({
      success: true,
      data: {
        events: eventsResult.rows,
        stats: {
          totalEvents: parseInt(stats.total_events) || 0,
          publishedEvents: parseInt(stats.published_events) || 0,
          draftEvents: parseInt(stats.draft_events) || 0,
          cancelledEvents: parseInt(stats.cancelled_events) || 0,
          newEvents30Days: parseInt(stats.new_events_30_days) || 0,
          totalSales: parseInt(sales.total_sales) || 0,
          totalRevenue: parseFloat(sales.total_revenue) || 0,
          eventsWithSales: parseInt(sales.events_with_sales) || 0,
          completedSales: parseInt(sales.completed_sales) || 0,
          pendingSales: parseInt(sales.pending_sales) || 0,
          failedSales: parseInt(sales.failed_sales) || 0,
          avgTicketPrice: parseFloat(sales.avg_ticket_price) || 0
        },
        recentEvents: recentEventsResult.rows
      }
    })

  } catch (error) {
    console.error('Error getting promoter dashboard:', error)
    res.status(500).json({
      success: false,
      error: 'Error interno del servidor'
    })
  }
})

// GET /api/promoter/events - Lista de eventos del promotor
router.get('/events', auth, requirePromoter, async (req, res) => {
  try {
    const promoterId = req.user.id
    const { page = 1, limit = 10, status = '', search = '' } = req.query
    const offset = (page - 1) * limit

    let whereClause = 'WHERE e.promoter_id = $1'
    const params = [promoterId]
    let paramIndex = 2

    if (status) {
      whereClause += ` AND e.status = $${paramIndex}`
      params.push(status)
      paramIndex++
    }

    if (search) {
      whereClause += ` AND (e.title ILIKE $${paramIndex} OR e.description ILIKE $${paramIndex})`
      params.push(`%${search}%`)
      paramIndex++
    }

    const eventsQuery = `
      SELECT 
        e.id,
        e.title,
        e.description,
        e.date,
        e.time,
        e.venue,
        e.status,
        e.created_at,
        c.name as category_name,
        COALESCE(e.total_capacity, 0) as capacity,
        COALESCE(e.price, 0) as price,
        COUNT(s.id) as total_sales,
        COALESCE(SUM(CASE WHEN s.status = 'completed' THEN s.total_amount ELSE 0 END), 0) as total_revenue
      FROM events e
      LEFT JOIN categories c ON e.category_id = c.id
      LEFT JOIN sales s ON e.id = s.event_id
      ${whereClause}
      GROUP BY e.id, e.title, e.description, e.date, e.time, e.venue, e.status, e.created_at, c.name, e.total_capacity, e.price
      ORDER BY e.created_at DESC
      LIMIT $${paramIndex} OFFSET $${paramIndex + 1}
    `

    const countQuery = `
      SELECT COUNT(*) as total
      FROM events e
      ${whereClause}
    `

    const [eventsResult, countResult] = await Promise.all([
      db.query(eventsQuery, [...params, limit, offset]),
      db.query(countQuery, params)
    ])

    res.json({
      success: true,
      data: {
        events: eventsResult.rows,
        pagination: {
          total: parseInt(countResult.rows[0].total),
          page: parseInt(page),
          limit: parseInt(limit),
          totalPages: Math.ceil(countResult.rows[0].total / limit)
        }
      }
    })

  } catch (error) {
    console.error('Error getting promoter events:', error)
    res.status(500).json({
      success: false,
      error: 'Error interno del servidor'
    })
  }
})

// GET /api/promoter/events/:id - Detalles de un evento específico
router.get('/events/:id', auth, requirePromoter, async (req, res) => {
  try {
    const { id } = req.params
    const promoterId = req.user.id

    // Verificar que el evento pertenece al promotor
    const eventQuery = `
      SELECT 
        e.*,
        c.name as category_name,
        COUNT(s.id) as total_sales,
        COALESCE(SUM(CASE WHEN s.status = 'completed' THEN s.total_amount ELSE 0 END), 0) as total_revenue,
        COUNT(CASE WHEN s.status = 'completed' THEN 1 END) as completed_sales,
        COUNT(CASE WHEN s.status = 'pending' THEN 1 END) as pending_sales,
        COUNT(CASE WHEN s.status = 'failed' THEN 1 END) as failed_sales,
        COUNT(DISTINCT s.buyer_id) as unique_buyers
      FROM events e
      LEFT JOIN categories c ON e.category_id = c.id
      LEFT JOIN sales s ON e.id = s.event_id
      WHERE e.id = $1 AND e.promoter_id = $2
      GROUP BY e.id, e.title, e.description, e.date, e.time, e.venue, e.status, e.created_at, c.name, e.total_capacity, e.price
    `

    const eventResult = await db.query(eventQuery, [id, promoterId])

    if (eventResult.rows.length === 0) {
      return res.status(404).json({
        success: false,
        error: 'Evento no encontrado o no tienes permisos para verlo'
      })
    }

    const event = eventResult.rows[0]

    // Obtener tipos de boletos del evento
    const ticketTypesQuery = `
      SELECT 
        tt.*,
        COUNT(t.id) as tickets_sold,
        COALESCE(SUM(t.price), 0) as revenue_generated
      FROM ticket_types tt
      LEFT JOIN tickets t ON tt.id = t.ticket_type_id
      WHERE tt.event_id = $1
      GROUP BY tt.id
      ORDER BY tt.price ASC
    `

    const ticketTypesResult = await db.query(ticketTypesQuery, [id])

    // Obtener ventas recientes del evento
    const recentSalesQuery = `
      SELECT 
        s.id,
        s.total_amount,
        s.status,
        s.transaction_date,
        s.buyer_email,
        COUNT(t.id) as tickets_count
      FROM sales s
      LEFT JOIN tickets t ON s.id = t.sale_id
      WHERE s.event_id = $1
      GROUP BY s.id, s.total_amount, s.status, s.transaction_date, s.buyer_email
      ORDER BY s.transaction_date DESC
      LIMIT 10
    `

    const recentSalesResult = await db.query(recentSalesQuery, [id])

    res.json({
      success: true,
      data: {
        event,
        ticketTypes: ticketTypesResult.rows,
        recentSales: recentSalesResult.rows
      }
    })

  } catch (error) {
    console.error('Error getting event details:', error)
    res.status(500).json({
      success: false,
      error: 'Error interno del servidor'
    })
  }
})

// GET /api/promoter/events/:id/analytics - Analytics de un evento específico
router.get('/events/:id/analytics', auth, requirePromoter, async (req, res) => {
  try {
    const { id } = req.params
    const promoterId = req.user.id

    // Verificar que el evento pertenece al promotor
    const eventCheckQuery = 'SELECT id FROM events WHERE id = $1 AND promoter_id = $2'
    const eventCheckResult = await db.query(eventCheckQuery, [id, promoterId])

    if (eventCheckResult.rows.length === 0) {
      return res.status(404).json({
        success: false,
        error: 'Evento no encontrado o no tienes permisos para verlo'
      })
    }

    // Obtener ventas por día
    const dailySalesQuery = `
      SELECT 
        DATE(s.transaction_date) as date,
        COUNT(*) as sales_count,
        COALESCE(SUM(s.total_amount), 0) as revenue,
        COUNT(DISTINCT s.buyer_id) as unique_buyers
      FROM sales s
      WHERE s.event_id = $1 AND s.status = 'completed'
      GROUP BY DATE(s.transaction_date)
      ORDER BY date
    `

    // Obtener ventas por hora
    const hourlySalesQuery = `
      SELECT 
        EXTRACT(HOUR FROM s.transaction_date) as hour,
        COUNT(*) as sales_count,
        COALESCE(SUM(s.total_amount), 0) as revenue
      FROM sales s
      WHERE s.event_id = $1 AND s.status = 'completed'
      GROUP BY EXTRACT(HOUR FROM s.transaction_date)
      ORDER BY hour
    `

    // Obtener distribución de tipos de boletos
    const ticketTypeDistributionQuery = `
      SELECT 
        tt.name,
        tt.price,
        COUNT(t.id) as tickets_sold,
        COALESCE(SUM(t.price), 0) as revenue_generated
      FROM ticket_types tt
      LEFT JOIN tickets t ON tt.id = t.ticket_type_id
      WHERE tt.event_id = $1
      GROUP BY tt.id, tt.name, tt.price
      ORDER BY tickets_sold DESC
    `

    // Obtener estadísticas generales
    const statsQuery = `
      SELECT 
        COUNT(*) as total_sales,
        COALESCE(SUM(s.total_amount), 0) as total_revenue,
        COUNT(DISTINCT s.buyer_id) as unique_buyers,
        COUNT(CASE WHEN s.status = 'completed' THEN 1 END) as completed_sales,
        COUNT(CASE WHEN s.status = 'pending' THEN 1 END) as pending_sales,
        COUNT(CASE WHEN s.status = 'failed' THEN 1 END) as failed_sales,
        COALESCE(AVG(s.total_amount), 0) as avg_ticket_price,
        COUNT(t.id) as total_tickets_sold
      FROM sales s
      LEFT JOIN tickets t ON s.id = t.sale_id
      WHERE s.event_id = $1
    `

    const [dailySalesResult, hourlySalesResult, ticketTypeResult, statsResult] = await Promise.all([
      db.query(dailySalesQuery, [id]),
      db.query(hourlySalesQuery, [id]),
      db.query(ticketTypeDistributionQuery, [id]),
      db.query(statsQuery, [id])
    ])

    // Procesar datos por hora (0-23)
    const hourlyData = []
    for (let hour = 0; hour < 24; hour++) {
      const hourData = hourlySalesResult.rows.find(row => parseInt(row.hour) === hour)
      hourlyData.push({
        hour: hour.toString().padStart(2, '0') + ':00',
        sales: hourData ? parseInt(hourData.sales_count) : 0,
        revenue: hourData ? parseFloat(hourData.revenue) : 0
      })
    }

    const stats = statsResult.rows[0]

    res.json({
      success: true,
      data: {
        dailySales: dailySalesResult.rows,
        hourlySales: hourlyData,
        ticketTypeDistribution: ticketTypeResult.rows,
        stats: {
          totalSales: parseInt(stats.total_sales) || 0,
          totalRevenue: parseFloat(stats.total_revenue) || 0,
          uniqueBuyers: parseInt(stats.unique_buyers) || 0,
          completedSales: parseInt(stats.completed_sales) || 0,
          pendingSales: parseInt(stats.pending_sales) || 0,
          failedSales: parseInt(stats.failed_sales) || 0,
          avgTicketPrice: parseFloat(stats.avg_ticket_price) || 0,
          totalTicketsSold: parseInt(stats.total_tickets_sold) || 0
        }
      }
    })

  } catch (error) {
    console.error('Error getting event analytics:', error)
    res.status(500).json({
      success: false,
      error: 'Error interno del servidor'
    })
  }
})

// GET /api/promoter/events/:id/attendees - Lista de asistentes de un evento
router.get('/events/:id/attendees', auth, requirePromoter, async (req, res) => {
  try {
    const { id } = req.params
    const promoterId = req.user.id
    const { page = 1, limit = 10, search = '' } = req.query
    const offset = (page - 1) * limit

    // Verificar que el evento pertenece al promotor
    const eventCheckQuery = 'SELECT id FROM events WHERE id = $1 AND promoter_id = $2'
    const eventCheckResult = await db.query(eventCheckQuery, [id, promoterId])

    if (eventCheckResult.rows.length === 0) {
      return res.status(404).json({
        success: false,
        error: 'Evento no encontrado o no tienes permisos para verlo'
      })
    }

    let whereClause = 'WHERE s.event_id = $1'
    const params = [id]
    let paramIndex = 2

    if (search) {
      whereClause += ` AND (s.buyer_email ILIKE $${paramIndex} OR s.buyer_name ILIKE $${paramIndex})`
      params.push(`%${search}%`)
      paramIndex++
    }

    const attendeesQuery = `
      SELECT 
        s.id as sale_id,
        s.buyer_email,
        s.buyer_name,
        s.total_amount,
        s.status,
        s.transaction_date,
        COUNT(t.id) as tickets_count,
        STRING_AGG(tt.name, ', ') as ticket_types
      FROM sales s
      LEFT JOIN tickets t ON s.id = t.sale_id
      LEFT JOIN ticket_types tt ON t.ticket_type_id = tt.id
      ${whereClause}
      GROUP BY s.id, s.buyer_email, s.buyer_name, s.total_amount, s.status, s.transaction_date
      ORDER BY s.transaction_date DESC
      LIMIT $${paramIndex} OFFSET $${paramIndex + 1}
    `

    const countQuery = `
      SELECT COUNT(DISTINCT s.id) as total
      FROM sales s
      ${whereClause}
    `

    const [attendeesResult, countResult] = await Promise.all([
      db.query(attendeesQuery, [...params, limit, offset]),
      db.query(countQuery, params)
    ])

    res.json({
      success: true,
      data: {
        attendees: attendeesResult.rows,
        pagination: {
          total: parseInt(countResult.rows[0].total),
          page: parseInt(page),
          limit: parseInt(limit),
          totalPages: Math.ceil(countResult.rows[0].total / limit)
        }
      }
    })

  } catch (error) {
    console.error('Error getting event attendees:', error)
    res.status(500).json({
      success: false,
      error: 'Error interno del servidor'
    })
  }
})

// GET /api/promoter/events/:id/sales - Ventas de un evento específico
router.get('/events/:id/sales', auth, requirePromoter, async (req, res) => {
  try {
    const { id } = req.params
    const promoterId = req.user.id
    const { page = 1, limit = 10, status = '', startDate = '', endDate = '' } = req.query
    const offset = (page - 1) * limit

    // Verificar que el evento pertenece al promotor
    const eventCheckQuery = 'SELECT id FROM events WHERE id = $1 AND promoter_id = $2'
    const eventCheckResult = await db.query(eventCheckQuery, [id, promoterId])

    if (eventCheckResult.rows.length === 0) {
      return res.status(404).json({
        success: false,
        error: 'Evento no encontrado o no tienes permisos para verlo'
      })
    }

    let whereClause = 'WHERE s.event_id = $1'
    const params = [id]
    let paramIndex = 2

    if (status) {
      whereClause += ` AND s.status = $${paramIndex}`
      params.push(status)
      paramIndex++
    }

    if (startDate) {
      whereClause += ` AND s.transaction_date >= $${paramIndex}`
      params.push(startDate)
      paramIndex++
    }

    if (endDate) {
      whereClause += ` AND s.transaction_date <= $${paramIndex}`
      params.push(endDate)
      paramIndex++
    }

    const salesQuery = `
      SELECT 
        s.id,
        s.total_amount,
        s.status,
        s.transaction_date,
        s.buyer_email,
        s.buyer_name,
        s.payment_method,
        COUNT(t.id) as tickets_count,
        STRING_AGG(tt.name, ', ') as ticket_types
      FROM sales s
      LEFT JOIN tickets t ON s.id = t.sale_id
      LEFT JOIN ticket_types tt ON t.ticket_type_id = tt.id
      ${whereClause}
      GROUP BY s.id, s.total_amount, s.status, s.transaction_date, s.buyer_email, s.buyer_name, s.payment_method
      ORDER BY s.transaction_date DESC
      LIMIT $${paramIndex} OFFSET $${paramIndex + 1}
    `

    const countQuery = `
      SELECT COUNT(*) as total
      FROM sales s
      ${whereClause}
    `

    const [salesResult, countResult] = await Promise.all([
      db.query(salesQuery, [...params, limit, offset]),
      db.query(countQuery, params)
    ])

    res.json({
      success: true,
      data: {
        sales: salesResult.rows,
        pagination: {
          total: parseInt(countResult.rows[0].total),
          page: parseInt(page),
          limit: parseInt(limit),
          totalPages: Math.ceil(countResult.rows[0].total / limit)
        }
      }
    })

  } catch (error) {
    console.error('Error getting event sales:', error)
    res.status(500).json({
      success: false,
      error: 'Error interno del servidor'
    })
  }
})

// GET /api/promoter/reports - Reportes generales del promotor
router.get('/reports', auth, requirePromoter, async (req, res) => {
  try {
    const promoterId = req.user.id
    const { startDate = '', endDate = '' } = req.query

    let dateFilter = ''
    const params = [promoterId]
    let paramIndex = 2

    if (startDate && endDate) {
      dateFilter = `AND s.transaction_date BETWEEN $${paramIndex} AND $${paramIndex + 1}`
      params.push(startDate, endDate)
      paramIndex += 2
    }

    // Reporte de ventas por evento
    const salesByEventQuery = `
      SELECT 
        e.id,
        e.title,
        e.date,
        COUNT(s.id) as total_sales,
        COALESCE(SUM(s.total_amount), 0) as total_revenue,
        COUNT(CASE WHEN s.status = 'completed' THEN 1 END) as completed_sales,
        COUNT(DISTINCT s.buyer_id) as unique_buyers
      FROM events e
      LEFT JOIN sales s ON e.id = s.event_id ${dateFilter}
      WHERE e.promoter_id = $1
      GROUP BY e.id, e.title, e.date
      ORDER BY total_revenue DESC
    `

    // Reporte de tipos de boletos más vendidos
    const ticketTypesQuery = `
      SELECT 
        tt.name,
        tt.price,
        COUNT(t.id) as tickets_sold,
        COALESCE(SUM(t.price), 0) as revenue_generated,
        e.title as event_title
      FROM ticket_types tt
      LEFT JOIN tickets t ON tt.id = t.ticket_type_id
      LEFT JOIN events e ON tt.event_id = e.id
      WHERE e.promoter_id = $1 ${dateFilter.replace('s.transaction_date', 't.created_at')}
      GROUP BY tt.id, tt.name, tt.price, e.title
      ORDER BY tickets_sold DESC
      LIMIT 10
    `

    // Reporte de ventas por día
    const dailySalesQuery = `
      SELECT 
        DATE(s.transaction_date) as date,
        COUNT(*) as sales_count,
        COALESCE(SUM(s.total_amount), 0) as revenue,
        COUNT(DISTINCT s.buyer_id) as unique_buyers
      FROM sales s
      INNER JOIN events e ON s.event_id = e.id
      WHERE e.promoter_id = $1 ${dateFilter}
      GROUP BY DATE(s.transaction_date)
      ORDER BY date
    `

    const [salesByEventResult, ticketTypesResult, dailySalesResult] = await Promise.all([
      db.query(salesByEventQuery, params),
      db.query(ticketTypesQuery, params),
      db.query(dailySalesQuery, params)
    ])

    res.json({
      success: true,
      data: {
        salesByEvent: salesByEventResult.rows,
        topTicketTypes: ticketTypesResult.rows,
        dailySales: dailySalesResult.rows
      }
    })

  } catch (error) {
    console.error('Error getting promoter reports:', error)
    res.status(500).json({
      success: false,
      error: 'Error interno del servidor'
    })
  }
})

// PUT /api/promoter/events/:id - Actualizar evento del promotor
router.put('/events/:id', auth, requirePromoter, async (req, res) => {
  try {
    const { id } = req.params
    const promoterId = req.user.id
    const { title, description, date, time, venue, status, price, totalCapacity } = req.body

    // Verificar que el evento pertenece al promotor
    const eventCheckQuery = 'SELECT id FROM events WHERE id = $1 AND promoter_id = $2'
    const eventCheckResult = await db.query(eventCheckQuery, [id, promoterId])

    if (eventCheckResult.rows.length === 0) {
      return res.status(404).json({
        success: false,
        error: 'Evento no encontrado o no tienes permisos para editarlo'
      })
    }

    // Construir query de actualización
    let updateFields = []
    let params = []
    let paramIndex = 1

    if (title) {
      updateFields.push(`title = $${paramIndex}`)
      params.push(title)
      paramIndex++
    }

    if (description) {
      updateFields.push(`description = $${paramIndex}`)
      params.push(description)
      paramIndex++
    }

    if (date) {
      updateFields.push(`date = $${paramIndex}`)
      params.push(date)
      paramIndex++
    }

    if (time) {
      updateFields.push(`time = $${paramIndex}`)
      params.push(time)
      paramIndex++
    }

    if (venue) {
      updateFields.push(`venue = $${paramIndex}`)
      params.push(venue)
      paramIndex++
    }

    if (status) {
      updateFields.push(`status = $${paramIndex}`)
      params.push(status)
      paramIndex++
    }

    if (price !== undefined) {
      updateFields.push(`price = $${paramIndex}`)
      params.push(price)
      paramIndex++
    }

    if (totalCapacity !== undefined) {
      updateFields.push(`total_capacity = $${paramIndex}`)
      params.push(totalCapacity)
      paramIndex++
    }

    if (updateFields.length === 0) {
      return res.status(400).json({
        success: false,
        error: 'No se proporcionaron campos para actualizar'
      })
    }

    // Agregar updated_at
    updateFields.push(`updated_at = NOW()`)

    // Ejecutar actualización
    const updateQuery = `
      UPDATE events 
      SET ${updateFields.join(', ')}
      WHERE id = $${paramIndex} AND promoter_id = $${paramIndex + 1}
      RETURNING *
    `
    params.push(id, promoterId)

    const result = await db.query(updateQuery, params)
    const updatedEvent = result.rows[0]

    res.json({
      success: true,
      message: 'Evento actualizado exitosamente',
      data: {
        event: updatedEvent
      }
    })

  } catch (error) {
    console.error('Error updating event:', error)
    res.status(500).json({
      success: false,
      error: 'Error interno del servidor'
    })
  }
})

// DELETE /api/promoter/events/:id - Eliminar evento del promotor
router.delete('/events/:id', auth, requirePromoter, async (req, res) => {
  try {
    const { id } = req.params
    const promoterId = req.user.id

    // Verificar que el evento pertenece al promotor
    const eventCheckQuery = 'SELECT id, status FROM events WHERE id = $1 AND promoter_id = $2'
    const eventCheckResult = await db.query(eventCheckQuery, [id, promoterId])

    if (eventCheckResult.rows.length === 0) {
      return res.status(404).json({
        success: false,
        error: 'Evento no encontrado o no tienes permisos para eliminarlo'
      })
    }

    const event = eventCheckResult.rows[0]

    // Verificar si el evento tiene ventas
    const salesCheckQuery = 'SELECT COUNT(*) as sales_count FROM sales WHERE event_id = $1'
    const salesCheckResult = await db.query(salesCheckQuery, [id])

    if (parseInt(salesCheckResult.rows[0].sales_count) > 0) {
      return res.status(400).json({
        success: false,
        error: 'No se puede eliminar un evento que tiene ventas asociadas'
      })
    }

    // Eliminar evento (cascada eliminará tipos de boletos y otros datos relacionados)
    await db.query('DELETE FROM events WHERE id = $1 AND promoter_id = $2', [id, promoterId])

    res.json({
      success: true,
      message: 'Evento eliminado exitosamente'
    })

  } catch (error) {
    console.error('Error deleting event:', error)
    res.status(500).json({
      success: false,
      error: 'Error interno del servidor'
    })
  }
})

module.exports = router
