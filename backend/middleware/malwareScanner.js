const fs = require('fs');
const path = require('path');
const { promisify } = require('util');
const fileType = require('file-type');
const NodeClam = require('node-clam');

/**
 * Middleware de escaneo de malware para uploads
 */
class MalwareScanner {
  constructor() {
    this.clamav = null;
    this.isInitialized = false;
    this.quarantineDir = path.join(__dirname, '../uploads/quarantine');
    this.safeDir = path.join(__dirname, '../uploads/safe');
    
    // Crear directorios si no existen
    this.ensureDirectories();
  }

  /**
   * Asegurar que los directorios de cuarentena y seguro existen
   */
  ensureDirectories() {
    [this.quarantineDir, this.safeDir].forEach(dir => {
      if (!fs.existsSync(dir)) {
        fs.mkdirSync(dir, { recursive: true, mode: 0o700 });
        console.log(`üìÅ Directorio creado: ${dir}`);
      }
    });
  }

  /**
   * Inicializar ClamAV
   */
  async initialize() {
    try {
      this.clamav = await NodeClam.init({
        removeInfected: false, // No eliminar autom√°ticamente
        quarantineInfected: false, // No poner en cuarentena autom√°ticamente
        scanLog: path.join(__dirname, '../logs/clamav.log'),
        debugMode: process.env.NODE_ENV === 'development',
        fileList: null,
        scanRecursively: false,
        clamscan: {
          path: '/usr/bin/clamscan', // Ruta de ClamAV
          db: null,
          scanArchives: true,
          active: true
        },
        preference: 'clamscan'
      });

      this.isInitialized = true;
      console.log('üõ°Ô∏è ClamAV inicializado correctamente');
    } catch (error) {
      console.warn('‚ö†Ô∏è ClamAV no disponible, usando validaci√≥n b√°sica:', error.message);
      this.isInitialized = false;
    }
  }

  /**
   * Validar tipo de archivo por contenido (no solo extensi√≥n)
   */
  async validateFileType(filePath) {
    try {
      const fileInfo = await fileType.fromFile(filePath);
      
      if (!fileInfo) {
        return {
          isValid: false,
          reason: 'No se pudo determinar el tipo de archivo'
        };
      }

      // Tipos de archivo permitidos
      const allowedTypes = [
        'image/jpeg',
        'image/png',
        'image/gif',
        'image/webp',
        'application/pdf',
        'application/msword',
        'application/vnd.openxmlformats-officedocument.wordprocessingml.document'
      ];

      if (!allowedTypes.includes(fileInfo.mime)) {
        return {
          isValid: false,
          reason: `Tipo de archivo no permitido: ${fileInfo.mime}`
        };
      }

      return {
        isValid: true,
        mimeType: fileInfo.mime,
        extension: fileInfo.ext
      };
    } catch (error) {
      console.error('Error validando tipo de archivo:', error);
      return {
        isValid: false,
        reason: 'Error validando tipo de archivo'
      };
    }
  }

  /**
   * Escanear archivo con ClamAV
   */
  async scanFile(filePath) {
    if (!this.isInitialized) {
      console.warn('‚ö†Ô∏è ClamAV no inicializado, saltando escaneo');
      return {
        isClean: true,
        reason: 'ClamAV no disponible'
      };
    }

    try {
      const result = await this.clamav.scanFile(filePath);
      
      if (result.isInfected) {
        console.warn(`üö® Archivo infectado detectado: ${filePath}`, result.viruses);
        return {
          isClean: false,
          reason: `Malware detectado: ${result.viruses.join(', ')}`,
          viruses: result.viruses
        };
      }

      return {
        isClean: true,
        reason: 'Archivo limpio'
      };
    } catch (error) {
      console.error('Error escaneando archivo:', error);
      return {
        isClean: false,
        reason: 'Error durante el escaneo'
      };
    }
  }

  /**
   * Validaciones adicionales de seguridad
   */
  async performSecurityChecks(filePath) {
    const checks = [];

    // 1. Verificar tama√±o del archivo
    const stats = fs.statSync(filePath);
    const maxSize = 10 * 1024 * 1024; // 10MB
    if (stats.size > maxSize) {
      checks.push({
        passed: false,
        reason: `Archivo demasiado grande: ${(stats.size / 1024 / 1024).toFixed(2)}MB (m√°ximo: 10MB)`
      });
    } else {
      checks.push({
        passed: true,
        reason: 'Tama√±o de archivo v√°lido'
      });
    }

    // 2. Verificar que no sea un archivo ejecutable
    const executableExtensions = ['.exe', '.bat', '.cmd', '.com', '.scr', '.pif', '.vbs', '.js', '.jar'];
    const ext = path.extname(filePath).toLowerCase();
    if (executableExtensions.includes(ext)) {
      checks.push({
        passed: false,
        reason: `Archivo ejecutable no permitido: ${ext}`
      });
    } else {
      checks.push({
        passed: true,
        reason: 'No es un archivo ejecutable'
      });
    }

    // 3. Verificar contenido del archivo (primeros bytes)
    try {
      const buffer = fs.readFileSync(filePath, { start: 0, end: 1023 });
      const content = buffer.toString('utf8', 0, Math.min(1024, buffer.length));
      
      // Buscar patrones sospechosos
      const suspiciousPatterns = [
        /<script/i,
        /javascript:/i,
        /vbscript:/i,
        /onload=/i,
        /onerror=/i,
        /eval\(/i,
        /document\.write/i
      ];

      const hasSuspiciousContent = suspiciousPatterns.some(pattern => pattern.test(content));
      if (hasSuspiciousContent) {
        checks.push({
          passed: false,
          reason: 'Contenido sospechoso detectado en el archivo'
        });
      } else {
        checks.push({
          passed: true,
          reason: 'Contenido del archivo parece seguro'
        });
      }
    } catch (error) {
      checks.push({
        passed: false,
        reason: 'Error leyendo contenido del archivo'
      });
    }

    return checks;
  }

  /**
   * Mover archivo a cuarentena
   */
  async quarantineFile(filePath, reason) {
    try {
      const fileName = path.basename(filePath);
      const timestamp = new Date().toISOString().replace(/[:.]/g, '-');
      const quarantinePath = path.join(this.quarantineDir, `${timestamp}_${fileName}`);
      
      await fs.promises.rename(filePath, quarantinePath);
      
      // Crear archivo de log de cuarentena
      const logPath = path.join(this.quarantineDir, `${timestamp}_${fileName}.log`);
      const logContent = {
        originalPath: filePath,
        quarantinePath: quarantinePath,
        reason: reason,
        timestamp: new Date().toISOString(),
        fileSize: fs.statSync(quarantinePath).size
      };
      
      await fs.promises.writeFile(logPath, JSON.stringify(logContent, null, 2));
      
      console.warn(`üö® Archivo puesto en cuarentena: ${fileName} - Raz√≥n: ${reason}`);
      
      return quarantinePath;
    } catch (error) {
      console.error('Error poniendo archivo en cuarentena:', error);
      throw error;
    }
  }

  /**
   * Mover archivo a directorio seguro
   */
  async moveToSafe(filePath) {
    try {
      const fileName = path.basename(filePath);
      const safePath = path.join(this.safeDir, fileName);
      
      // Si ya existe un archivo con el mismo nombre, agregar timestamp
      if (fs.existsSync(safePath)) {
        const ext = path.extname(fileName);
        const name = path.basename(fileName, ext);
        const timestamp = Date.now();
        const newFileName = `${name}_${timestamp}${ext}`;
        const newSafePath = path.join(this.safeDir, newFileName);
        await fs.promises.rename(filePath, newSafePath);
        return newSafePath;
      } else {
        await fs.promises.rename(filePath, safePath);
        return safePath;
      }
    } catch (error) {
      console.error('Error moviendo archivo a directorio seguro:', error);
      throw error;
    }
  }

  /**
   * Proceso completo de escaneo de archivo
   */
  async scanUpload(filePath) {
    const results = {
      isSafe: false,
      checks: [],
      finalPath: null,
      errors: []
    };

    try {
      // 1. Validar tipo de archivo
      const fileTypeResult = await this.validateFileType(filePath);
      results.checks.push({
        type: 'file_type',
        passed: fileTypeResult.isValid,
        reason: fileTypeResult.reason || 'Tipo de archivo v√°lido'
      });

      if (!fileTypeResult.isValid) {
        results.errors.push(fileTypeResult.reason);
        await this.quarantineFile(filePath, fileTypeResult.reason);
        return results;
      }

      // 2. Realizar verificaciones de seguridad
      const securityChecks = await this.performSecurityChecks(filePath);
      results.checks.push(...securityChecks.map(check => ({
        type: 'security_check',
        passed: check.passed,
        reason: check.reason
      })));

      const failedSecurityChecks = securityChecks.filter(check => !check.passed);
      if (failedSecurityChecks.length > 0) {
        results.errors.push(...failedSecurityChecks.map(check => check.reason));
        await this.quarantineFile(filePath, failedSecurityChecks[0].reason);
        return results;
      }

      // 3. Escanear con ClamAV
      const scanResult = await this.scanFile(filePath);
      results.checks.push({
        type: 'malware_scan',
        passed: scanResult.isClean,
        reason: scanResult.reason
      });

      if (!scanResult.isClean) {
        results.errors.push(scanResult.reason);
        await this.quarantineFile(filePath, scanResult.reason);
        return results;
      }

      // 4. Si todo est√° bien, mover a directorio seguro
      results.finalPath = await this.moveToSafe(filePath);
      results.isSafe = true;

      console.log(`‚úÖ Archivo escaneado y aprobado: ${path.basename(filePath)}`);
      return results;

    } catch (error) {
      console.error('Error durante el escaneo:', error);
      results.errors.push('Error interno durante el escaneo');
      await this.quarantineFile(filePath, 'Error interno durante el escaneo');
      return results;
    }
  }
}

// Instancia singleton
const malwareScanner = new MalwareScanner();

// Middleware para Express
const malwareScanMiddleware = async (req, res, next) => {
  if (!req.file && !req.files) {
    return next();
  }

  try {
    // Inicializar scanner si no est√° inicializado
    if (!malwareScanner.isInitialized) {
      await malwareScanner.initialize();
    }

    const filesToScan = req.files ? req.files : [req.file];
    const scanResults = [];

    for (const file of filesToScan) {
      if (file && file.path) {
        const result = await malwareScanner.scanUpload(file.path);
        scanResults.push({
          originalName: file.originalname,
          result: result
        });

        if (!result.isSafe) {
          // Si alg√∫n archivo no es seguro, rechazar toda la petici√≥n
          return res.status(400).json({
            success: false,
            message: 'Archivo no seguro detectado',
            details: result.errors,
            file: file.originalname
          });
        }

        // Actualizar la ruta del archivo con la ruta segura
        file.path = result.finalPath;
      }
    }

    // Agregar resultados del escaneo a la petici√≥n
    req.scanResults = scanResults;
    next();

  } catch (error) {
    console.error('Error en middleware de escaneo de malware:', error);
    return res.status(500).json({
      success: false,
      message: 'Error interno del servidor durante el escaneo'
    });
  }
};

module.exports = {
  MalwareScanner,
  malwareScanMiddleware,
  malwareScanner
};
